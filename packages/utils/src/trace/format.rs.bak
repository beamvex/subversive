use std::thread;

use crate::tui::color::*;
use super::types::TraceId;

impl TraceId {
    pub fn message(&self) -> String {
        // Try each category of messages
        if let Some(msg) = self.format_startup_category() {
            return msg;
        }
        if let Some(msg) = self.format_network_scan_category() {
            return msg;
        }
        if let Some(msg) = self.format_peer_connection_category() {
            return msg;
        }
        if let Some(msg) = self.format_peer_management_category() {
            return msg;
        }
        if let Some(msg) = self.format_peer_discovery_category() {
            return msg;
        }

        unreachable!("All TraceId variants should be handled in category functions")
    }

    fn format_startup_category(&self) -> Option<String> {
        match self {
            TraceId::StartupInit { port } => Some(self.format_startup_message(port)),
            TraceId::StartupPoc => Some(self.format_startup_message_simple()),
            TraceId::BuildHttpClient => Some(green("Building HTTP client for peer connection")),
            TraceId::UserPrompt => Some(green("Press Ctrl+C to exit")),
            _ => None
        }
    }

    fn format_network_scan_category(&self) -> Option<String> {
        match self {
            TraceId::NetworkScan => Some(green("Attempting to connect to all peers")),
            _ => None
        }
    }

    fn format_peer_connection_category(&self) -> Option<String> {
        match self {
            TraceId::PeerConnect { peer } => Some(self.format_peer_connect_message(peer)),
            TraceId::PeerInit { peer, source } => Some(self.format_peer_init_message(peer, source)),
            TraceId::PeerConnected { peer } => Some(self.format_peer_connected_message(peer)),
            TraceId::PeerConnectError { peer, error } => Some(self.format_peer_error_message(peer, error)),
            _ => None
        }
    }

    fn format_peer_management_category(&self) -> Option<String> {
        match self {
            TraceId::PeerAlreadyConnected { peer } => 
                Some(self.format_peer_status_message("Already connected to peer", peer)),
            TraceId::PeerRemoved { peer } => 
                Some(self.format_peer_status_message("Removed peer", peer)),
            TraceId::PeerNotFound { peer } => 
                Some(self.format_peer_not_found_message(peer)),
            TraceId::PeerLastSeen { peer } => 
                Some(self.format_peer_status_message("Updating last seen for peer", peer)),
            _ => None
        }
    }

    fn format_peer_discovery_category(&self) -> Option<String> {
        match self {
            TraceId::PeerAddOwn { peer } => 
                Some(self.format_peer_status_message("Adding own peer to initial peer", peer)),
            TraceId::PeerAddRequest { peer } => 
                Some(self.format_peer_status_message("Requesting to add peer", peer)),
            TraceId::PeerResponse { peer } => 
                Some(self.format_peer_status_message("Response from initial peer", peer)),
            TraceId::PeerKnownCount { peer, count } => 
                Some(self.format_peer_count_message(peer, count)),
            _ => None
        }
    }

    fn format_startup_message(&self, port: &u16) -> String {
        format!("{} {}", 
            green("Starting subversive node on port"), 
            magenta(&port.to_string())
        )
    }

    fn format_startup_message_simple(&self) -> String {
        green("Starting subversive poc going to run multiple peers at once to test the network")
    }

    fn format_peer_connect_message(&self, peer: &str) -> String {
        format!("{} {}", 
            green("Connecting to initial peer:"), 
            magenta(peer)
        )
    }

    fn format_peer_init_message(&self, peer: &str, source: &str) -> String {
        format!("{} {} {} {}", 
            green("Adding initial peer to peer list:"), 
            magenta(peer),
            green("from"), 
            magenta(source)
        )
    }

    fn format_peer_connected_message(&self, peer: &str) -> String {
        format!("{} {}", 
            green("Successfully connected to peer:"), 
            magenta(peer)
        )
    }

    fn format_peer_error_message(&self, peer: &str, error: &str) -> String {
        format!("{} {} {} {}", 
            green("Failed to connect to peer:"), 
            magenta(peer),
            green("-"), 
            magenta(error)
        )
    }

    fn format_peer_status_message(&self, status: &str, peer: &str) -> String {
        format!("{} {}", 
            green(status), 
            magenta(peer)
        )
    }

    fn format_peer_not_found_message(&self, peer: &str) -> String {
        format!("{} {} {}", 
            green("Peer"), 
            magenta(peer), 
            green("not found")
        )
    }

    fn format_peer_count_message(&self, peer: &str, count: &usize) -> String {
        format!("{} {} {} {}", 
            green("Received"), 
            magenta(&count.to_string()),
            green("known peers from"), 
            magenta(peer)
        )
    }
    }

/// Format a message ID for logging with yellow color
pub fn format_msg_id(id: &TraceId) -> String {
    let name = match id {
        TraceId::StartupInit { .. } => "StartupInit",
        TraceId::StartupPoc => "StartupPoc",
        TraceId::PeerConnect { .. } => "PeerConnect",
        TraceId::PeerInit { .. } => "PeerInit",
        TraceId::NetworkScan => "NetworkScan",
        TraceId::UserPrompt => "UserPrompt",
        TraceId::BuildHttpClient => "BuildHttpClient",
        TraceId::PeerAlreadyConnected { .. } => "PeerAlreadyConnected",
        TraceId::PeerRemoved { .. } => "PeerRemoved",
        TraceId::PeerNotFound { .. } => "PeerNotFound",
        TraceId::PeerLastSeen { .. } => "PeerLastSeen",
        TraceId::PeerAddOwn { .. } => "PeerAddOwn",
        TraceId::PeerAddRequest { .. } => "PeerAddRequest",
        TraceId::PeerResponse { .. } => "PeerResponse",
        TraceId::PeerConnected { .. } => "PeerConnected",
        TraceId::PeerKnownCount { .. } => "PeerKnownCount",
        TraceId::PeerConnectError { .. } => "PeerConnectError",
    };
    format!("[{}]", yellow(name))
}

/// Get the current thread ID as a colored string (cyan)
pub fn get_thread_id() -> String {
    format!("[{}]", cyan(&format!("{:?}", thread::current().id())))
}
